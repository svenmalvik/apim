<policies>
    <inbound> 
        
            <rate-limit-by-key calls="5" renewal-period="5" increment-condition="@(context.Response.StatusCode &gt;= 200)" counter-key="@(context.Request.Headers.GetValueOrDefault(&quot;X-Device-Id&quot;,&quot;&quot;))" />
        
        <rate-limit-by-key calls="5" renewal-period="5" increment-condition="@(context.Response.StatusCode &gt;= 200)" counter-key="@(context.Request.Headers.GetValueOrDefault(&quot;X-Device-Id&quot;,&quot;&quot;))" />
        <choose>
  <when condition="@({{IsVippsDown}} &amp;&amp; !Convert.ToBoolean(context.Request.Headers.GetValueOrDefault(&quot;X-Developer-Access&quot;, &quot;false&quot;)))">

		<log-to-eventhub logger-id="{{EventHub-Logger-Id}}">@{
												var header = "Environment\tProductName\tUtcDate\tInstance\tRegion\tRequestId\tClientIp\tUserEmail\tApiName\tApiPath\tOperationName\tSubscriptionId\tRequestUrl\tMethod\tStatusCode\tRequestBody\tCorrelationId\tDeviceId\tUserId\tResponseCode\tTotalDuration\tBackendTime";
												var values = string.Empty;
												var clientIP = context.Request.IpAddress;
												var forwarderIP = context.Request.Headers.GetValueOrDefault("X-Forwarded-For", "");
												
												if(!string.IsNullOrEmpty(forwarderIP))
												{
														clientIP = forwarderIP.Split(',').FirstOrDefault().Split(':').FirstOrDefault();
												}
												try
												{
														var requestBody = "NO_BODY";
														if({{IsRequestBodyLogEnabled}} &amp;&amp; context.Request.Body != null)
														{
																requestBody = context.Variables.ContainsKey("tempRequestBody") ? Regex.Replace((string)context.Variables["tempRequestBody"], @"\r\n?|\n|\r|\t", "") :  Regex.Replace(context.Request.Body.As&lt;string&gt;(true), @"\r\n?|\n|\r|\t", "");
														}
														var userId = context.Request.Headers.GetValueOrDefault("X-Customer-Id",   "");
														var totalDurationMS = 0;
														var backendTimeMS = 0;
														var responseCode = "4060";
														
														values = string.Join("\t", "{{EnvironmentName}}", context.Product.Name, DateTime.UtcNow.ToString("s") + "Z", context.Deployment.ServiceName,context.Deployment.Region, context.RequestId, clientIP,context.User.Email, context.Api.Name, context.Api.Path, context.Operation.Name,context.Subscription.Id,context.Request.Url.ToUri().ToString(),context.Request.Method, context.Response.StatusCode, requestBody, context.Request.Headers.GetValueOrDefault("X-Global-Context-Id",   ""),context.Request.Headers.GetValueOrDefault("X-Device-Id",   ""),userId,responseCode,totalDurationMS,backendTimeMS);
												}
												catch
												{
														values = string.Join("\t", "{{EnvironmentName}}", context.Product.Name, DateTime.UtcNow.ToString("s") + "Z", context.Deployment.ServiceName,context.Deployment.Region, context.RequestId, clientIP,context.User.Email, context.Api.Name, context.Api.Path, context.Operation.Name,context.Subscription.Id,context.Request.Url.ToUri().ToString(),context.Request.Method, context.Response.StatusCode, "APIMLOGEXCEPTION", context.Request.Headers.GetValueOrDefault("X-Global-Context-Id",   ""),context.Request.Headers.GetValueOrDefault("X-Device-Id",   ""),"APIMLOGEXCEPTION","APIMLOGEXCEPTION","APIMLOGEXCEPTION","APIMLOGEXCEPTION");
												}
												
												return header + "\n" + values;
										}
		</log-to-eventhub>

		<return-response response-variable-name="existing response variable">
			<set-status code="200" reason="Vipps Down" />
			<set-body>@{
												var errorMessage = (context.Request.Headers.GetValueOrDefault("Accept-Language",   "")).Trim().StartsWith("nb") ? "er ikke tilgjengelig akkurat nå.\nLes mer på vipps.no!" : "is currently experiencing some technical problems.\nPlease try again later or go to vipps.no.";
												var response = new {
																responseInfo = new {
																		responseCode = 4060,
																		responseMessage = errorMessage},
																result = new {
																		message = "There is some error in backend service"}
																		};
																												
												return JsonConvert.SerializeObject(response);
										}</set-body>
		</return-response>
	</when>
</choose>
        <set-variable name="ReqInTime" value="@(System.DateTime.Now)" />
        <set-header name="X-App-Type" exists-action="override">
            <value>VIPPS</value>
        </set-header>
        <!--   BEGIN - Token Validation   -->
<check-header name="Authorization" failed-check-httpcode="400" failed-check-error-message="Bad Request. Supplied token format is not valid!" ignore-case="true">
<value>@{
	var tokenInRequest = context.Request.Headers.GetValueOrDefault("Authorization",   "");
	var regex = new Regex(@"^bearer [a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$", RegexOptions.IgnoreCase);
	
	return (regex.Match(tokenInRequest)).Success ? tokenInRequest : "INVALIDTOKEN";
	}</value>
</check-header>
<!--   CUSTOM - Check if token is already expired or not   -->
<set-variable value="@{ var tokenInRequest = context.Request.Headers.GetValueOrDefault(&quot;Authorization&quot;,   &quot;&quot;);if(!string.IsNullOrEmpty(tokenInRequest)) { tokenInRequest = tokenInRequest.Remove(0, 7); } Jwt formattedToken = null; var isExpired = false; var timeSpan = new TimeSpan(); if (tokenInRequest.TryParseJwt(out formattedToken)) {return formattedToken;} else { throw new Exception(&quot;Supplied token format is not valid!&quot;);&#xA;                                    }&#xA;                                }" name="access_token" />
<choose>
	<when condition="@{&#xA;                                        var formattedToken = (Jwt)context.Variables[&quot;access_token&quot;];&#xA;                                        var expiryTime = formattedToken.ExpirationTime ?? DateTime.Now;&#xA;                                        var timeSpan = System.DateTime.Now.Subtract(expiryTime);&#xA;&#xA;                                        return timeSpan.TotalMinutes &gt; 0 ? true : false;&#xA;                                        }">
	<return-response response-variable-name="existing response variable">
		<set-status code="200" reason="Ok" />
		<set-body>@{
				var response = new {
										responseInfo = new {
											responseCode = 403,
											responseMessage = "Forbidden. Access token is expired"
											}
									};
									
				return JsonConvert.SerializeObject(response);
			}</set-body>
	</return-response>
	</when>
	</choose>
	<!--   CUSTOM - Check if token is already expired or not   -->
	<set-header name="X-Device-Id" exists-action="override">
	<value>
			@{ 
				var token = (Jwt)context.Variables["access_token"]; 
				return token.Claims.GetValueOrDefault("did", "");
				}
		</value>
	</set-header>
	<set-header name="X-Device-Platform" exists-action="override">
	<value>
			@{ 
				var token = (Jwt)context.Variables["access_token"]; 
				return token.Claims.GetValueOrDefault("dep", "");
				}
		</value>
	</set-header>
	<set-header name="X-Device-OS" exists-action="override">
	<value>
			@{ 
				var token = (Jwt)context.Variables["access_token"]; 
				return token.Claims.GetValueOrDefault("dos", "");
				}
		</value>
	</set-header>
	<set-header name="X-App-Version" exists-action="override">
	<value>
			@{ 
				var token = (Jwt)context.Variables["access_token"]; 
				return token.Claims.GetValueOrDefault("avr", "");
				}
		</value>
	</set-header>
	<set-header name="X-Customer-Mobile" exists-action="override">
	<value>
			@{ 
				var token = (Jwt)context.Variables["access_token"]; 
				return token.Claims.GetValueOrDefault("mob", "");
				}
		</value>
	</set-header>
	<set-header name="X-Customer-ID" exists-action="override">
	<value>
			@{ 
				var token = (Jwt)context.Variables["access_token"]; 
				return token.Claims.GetValueOrDefault("uid", "");
				}
		</value>
	</set-header>
	<validate-jwt failed-validation-error-message="Unauthorized. Access token is missing or invalid." failed-validation-httpcode="401" header-name="Authorization">
	<openid-config url="{{VippsP2POpenidConfigUrl}}" />
	<required-claims>
	<claim name="iss" match="all">
		<value>{{VippsP2PTokenIssuer}}</value>
	</claim>
	<claim name="tokenType" match="all">
		<value>AUTH</value>
	</claim>
	<claim name="appType" match="all">
		<value>VIPPS</value>
	</claim>
	</required-claims>
	</validate-jwt>
	<choose>
		<when condition="@{&#xA;                        var operationWhiteList = new List&lt;string&gt;()&#xA;                                            {&#xA;                                                &quot;DeleteAddress_v1&quot;, &quot;GetAddressList_v1&quot;, &quot;SyncAddress_v1&quot;, &quot;SyncAndUpdateAddress_v1&quot;, &quot;UpdateAddress_v1&quot;, &quot;FetchAllGroupChat_v1&quot;, &quot;GetAllRecentMessages_v1&quot;, &quot;GetMessagesByUser_v1&quot;,&#xA;                                                &quot;GetMessageUnreadCounts_v1&quot;, &quot;GetUserByNotification_v1&quot;, &quot;RequestUpdate_v1&quot;, &quot;SendMesage_v1&quot;, &quot;FetchRequestedImage_v1&quot;, &quot;GetBankImage_v1&quot;, &quot;GetSaleUnitImage_v1&quot;, &quot;UpdateP2PProfilePhoto_v1&quot;,&#xA;                                                &quot;GetInfocardDetails_v1&quot;, &quot;UpdateInfoCardAction_v1&quot;, &quot;GetOriginalInvoiceURL_v1&quot;, &quot;GetPendingInvoices_v1&quot;, &quot;InvoiceDetails_v1&quot;, &quot;GetMerchantDetails_v1&quot;, &quot;SearchLocation_v1&quot;,&#xA;                                                &quot;DeeplinkTransactionRequestDetails_v1&quot;, &quot;GetDueTransactionList_v1&quot;, &quot;GetLatestMerchantTransaction_v1&quot;, &quot;GetLatestMerchantTransaction_v2&quot;, &quot;GetSurchargeFee_v1&quot;, &quot;GetTransactionDetailsForMerchantPaymentVipps_v1&quot;, &quot;GetTransactionListByMerchant_v1&quot;,&#xA;                                                &quot;TransactionRequestDetails_v1&quot;, &quot;DeleteConsent_v1&quot;, &quot;GetAllConsents_v1&quot;, &quot;GetDeeplinkConsentDetails_v1&quot;, &quot;GetNotificationConsentDetails_v1&quot;, &quot;GetPendingRequests_v1&quot;, &quot;GetShippingMethods_v1&quot;,&#xA;                                                &quot;UpdateConsent_v1&quot;, &quot;GetSurchargeFee_v1&quot;, &quot;GetTransactionDetailsForP2PPaymentVipps_v1&quot;, &quot;GetTransactionLimits_v1&quot;, &quot;GetBankAccountDetails_v1&quot;, &quot;GetBestPaymentSource_v1&quot;, &quot;GetProfileDetails_v1&quot;,&#xA;                                                &quot;InvoiceStatusUpdate_v1&quot;, &quot;SearchP2PProfile_v1&quot;, &quot;SkipBankId_v1&quot;, &quot;AddExpense_v1&quot;, &quot;CreateGroup_v1&quot;, &quot;DeleteGroup_v1&quot;, &quot;EditExpense_v1&quot;, &quot;EditGroup_v1&quot;, &quot;FetchAllExpenseDistribution_v1&quot;,&#xA;                                                &quot;FetchAllExpensesByParticipant_v1&quot;, &quot;FetchAllGroups_v1&quot;, &quot;FetchAllParticipants_v1&quot;, &quot;FetchGroupBurden_v1&quot;, &quot;FetchSettlementExpense_v1&quot;, &quot;MarkAsSettled_v1&quot;, &quot;RemoveExpense_v1&quot;, &quot;SendMessageOnGroupChat_v1&quot;,&#xA;                                                &quot;GetBankIdURL_v1&quot;, &quot;GetBankName_v1&quot;, &quot;GetConfigParam_v1&quot;, &quot;GetDefaultCard_v1&quot;, &quot;GetPSP-URL_v1&quot;, &quot;RegisterPaymentCard_v1&quot;, &quot;ValidateDeepLink_v1&quot;, &quot;ValidatePaymentCard_v1&quot;, &quot;GetBankImage_v1&quot;,&#xA;                                                &quot;GetInvoicePaymentSource_v2&quot;, &quot;GetInvoiceSummary_v2&quot;, &quot;GetInvoiceURL_v2&quot;, &quot;GetTransactionByProvider_v2&quot;, &quot;GetTransactionDetail_v2&quot;, &quot;BlockUser_v1&quot;, &quot;GetBlockedUsers_v1&quot;, &quot;ReportAndBlockUser_v1&quot;, &quot;ReportUser_v1&quot;, &quot;UnBlockUser_v1&quot;,&#xA;                                                &quot;ListAgreementForUser_v1&quot;, &quot;GetAllActiveCharges_v1&quot;, &quot;FetchAgreementById_v1&quot;, &quot;UpdateAgreement_v1&quot;, &quot;GetChargeForAgreement_v1&quot;, &quot;GetSingleChargeForAgreement_v1&quot;&#xA;                                           };&#xA;                        return !operationWhiteList.Contains(context.Operation.Name);&#xA;                      }">
		<!--   BLACKLIST - Check if token is blacklisted   -->
		<send-request ignore-error="false" timeout="6" response-variable-name="BlacklistTokenResponse" mode="new">
			<set-url>{{VippsP2PTokenBlacklistUrl}}</set-url>
			<set-method>POST</set-method>
			<set-header name="X-Customer-Id" exists-action="override">
				<value>@(context.Request.Headers.GetValueOrDefault("X-Customer-Id",   ""))</value>
			</set-header>
			<set-header name="Content-Type" exists-action="override">
				<value>application/json</value>
			</set-header>
			<set-body>@{
			var tokenInRequest = context.Request.Headers.GetValueOrDefault("Authorization", "");
			if(!string.IsNullOrEmpty(tokenInRequest))
			{
				tokenInRequest = tokenInRequest.Remove(0, 7);
			}
			
			var requestBody = new {token = tokenInRequest};
			return JsonConvert.SerializeObject(requestBody);
		}</set-body>
		</send-request>
		<!--   BLACKLIST - Check if token is blacklisted   -->
		<set-variable name="blacklistResponseCode" value="@((string)(((IResponse)context.Variables[&quot;BlacklistTokenResponse&quot;]).Body.As&lt;JObject&gt;(true))[&quot;responseInfo&quot;][&quot;responseCode&quot;])" />
		<choose>
			<when condition="@((string)context.Variables[&quot;blacklistResponseCode&quot;] == &quot;4048&quot; ? true : false )">
				<return-response response-variable-name="InvalidTokenResponse">
					<set-status code="200" reason="Unauthorized. Access token is invalid." />
					<set-body>@{
							var errorMessage = (context.Request.Headers.GetValueOrDefault("Accept-Language",   "")).Trim().StartsWith("nb") ? "Du er  allerede  innlogget  i Vipps  på  en  annen  telefon. Vennligst  logg  inn på  Vipps  og  prøv  igjen." : "You are already logged into Vipps  on another device. Please log in to Vipps  and try again.";
							var response = new {
													responseInfo = new {
														responseCode = 9401,
														responseMessage = errorMessage},
													result = new {
														isBlacklisted = true,
														message = "Access token is blacklisted"}
												};
												
							return JsonConvert.SerializeObject(response);
						}</set-body>
				</return-response>
			</when>
			<when condition="@((string)context.Variables[&quot;blacklistResponseCode&quot;] == &quot;4074&quot; ? true : false )">
				<return-response response-variable-name="InvalidTokenResponse">
					<set-status code="200" reason="Ok" />
					<set-body>@{
							var response = new {
													responseInfo = new {
														responseCode = "7001",
														responseMessage = "Something went wrong. Please contact Vipps admin."}
												};
												
							return JsonConvert.SerializeObject(response);
						}</set-body>
				</return-response>
			</when>
			<when condition="@((string)context.Variables[&quot;blacklistResponseCode&quot;] != &quot;9000&quot; ? true : false )">
				<return-response response-variable-name="InvalidTokenResponse">
					<set-status code="200" reason="Something went wrong in backend application" />
					<set-body>@{
							var response = new {
													responseInfo = new {
														responseCode = 9500,
														responseMessage = "Backend server error."},
													result = new {
														message = "Backend server error. Something went wrong in backend application"}
												};
												
							return JsonConvert.SerializeObject(response);
						}</set-body>
				</return-response>
			</when>
		</choose>
	</when>	
</choose>
<!--   END - Token Validation   -->
        <set-variable name="tempRequestBody" value="@{ return context.Variables.ContainsKey(&quot;tempRequestBody&quot;) ? (string)context.Variables[&quot;tempRequestBody&quot;] : (context.Request.Body != null ? context.Request.Body.As&lt;string&gt;(true) : &quot;Request body is empty&quot;); }" />
        <set-header name="X-Auth-Source" exists-action="override">
            <value>APIM</value>
        </set-header>
        <set-header name="X-Global-Context-Id" exists-action="override">
            <value>@(context.RequestId.ToString())</value>
        </set-header>
        <set-header name="X-APIM-Secret-Key" exists-action="override">
            <value>{{APIM-SecretKey}}</value>
        </set-header>
        <send-one-way-request mode="copy">
            <set-url>{{BaseWAFAppgatewayUrl}}</set-url>
        </send-one-way-request>
        
            <choose>
		<when condition="@({{IsPeDown}})">
				<return-response>
						<set-status code="400" reason="Bad Request" />
						<set-header name="Content-Type" exists-action="override">
								<value>application/json;charset=UTF-8</value>
						</set-header>
						<set-body>{"kind": "unsupported"}</set-body>
				</return-response>
		</when>
</choose>
        
        <set-backend-service base-url="{{AKSBackendUrl}}/payments/v1" />
    </inbound>
    <backend>
        <choose>
		<when condition="@(true)">
				<!--    GET - Request Forward time    -->
				<set-variable name="ReqFwdTime" value="@(System.DateTime.Now)" />
				<choose>
						<when condition="@(context.Variables.GetValueOrDefault&lt;bool&gt;(&quot;isAks&quot;))">
								<set-backend-service base-url="{{AKSBackendUrl}}" />
						</when>
				</choose>
				<forward-request />
		</when>
</choose>
    </backend>
    <outbound>
        <choose>
<when condition="@(!{{IsVerboseLoggingEnabled}} &amp;&amp; context.Response.StatusCode &gt;= 300)">
					<log-to-eventhub logger-id="{{EventHub-Logger-Id}}">@{
							var header = "Environment\tProductName\tUtcDate\tInstance\tRegion\tRequestId\tClientIp\tUserEmail\tApiName\tApiPath\tOperationName\tSubscriptionId\tRequestUrl\tMethod\tStatusCode\tRequestBody\tCorrelationId\tDeviceId\tUserId\tResponseCode\tTotalDuration\tBackendTime";
									var values = string.Empty;
									var clientIP = context.Request.IpAddress;
									var forwarderIP = context.Request.Headers.GetValueOrDefault("X-Forwarded-For", "");
									
									if(!string.IsNullOrEmpty(forwarderIP))
									{
											clientIP = forwarderIP.Split(',').FirstOrDefault().Split(':').FirstOrDefault();
									}
									try
									{
											var requestBody = "NO_BODY";
											if({{IsRequestBodyLogEnabled}} &amp;&amp; context.Request.Body != null)
											{
													requestBody = context.Variables.ContainsKey("tempRequestBody") ? Regex.Replace((string)context.Variables["tempRequestBody"], @"\r\n?|\n|\r|\t", "") :  Regex.Replace(context.Request.Body.As&lt;string&gt;(true), @"\r\n?|\n|\r|\t", "");
											}
											var userId = context.Request.Headers.GetValueOrDefault("X-Customer-Id",   "");
											var totalDurationMS = (System.DateTime.Now.Subtract((DateTime)context.Variables["ReqInTime"])).TotalMilliseconds;
											var backendTimeMS = (System.DateTime.Now.Subtract((DateTime)context.Variables["ReqFwdTime"])).TotalMilliseconds;
											var responseCode = context.Response.Body != null ? (context.Response.Body.As&lt;JObject&gt;(true).SelectToken("responseInfo.responseCode") ?? context.Response.StatusCode).ToString() : context.Response.StatusCode.ToString();
											
											values = string.Join("\t", "{{EnvironmentName}}", context.Product.Name, DateTime.UtcNow.ToString("s") + "Z", context.Deployment.ServiceName,context.Deployment.Region, context.RequestId, clientIP,context.User.Email, context.Api.Name, context.Api.Path, context.Operation.Name,context.Subscription.Id,context.Request.Url.ToUri().ToString(),context.Request.Method, context.Response.StatusCode, requestBody, context.Request.Headers.GetValueOrDefault("X-Global-Context-Id",   ""),context.Request.Headers.GetValueOrDefault("X-Device-Id",   ""),userId,responseCode,totalDurationMS,backendTimeMS);
									}
									catch
									{
											values = string.Join("\t", "{{EnvironmentName}}", context.Product.Name, DateTime.UtcNow.ToString("s") + "Z", context.Deployment.ServiceName,context.Deployment.Region, context.RequestId, clientIP,context.User.Email, context.Api.Name, context.Api.Path, context.Operation.Name,context.Subscription.Id,context.Request.Url.ToUri().ToString(),context.Request.Method, context.Response.StatusCode, "APIMLOGEXCEPTION", context.Request.Headers.GetValueOrDefault("X-Global-Context-Id",   ""),context.Request.Headers.GetValueOrDefault("X-Device-Id",   ""),"APIMLOGEXCEPTION","APIMLOGEXCEPTION","APIMLOGEXCEPTION","APIMLOGEXCEPTION");
									}
									
									return header + "\n" + values;
					}</log-to-eventhub>
</when>
<when condition="{{IsVerboseLoggingEnabled}}">
					<log-to-eventhub logger-id="{{EventHub-Logger-Id}}">@{
							var header = "Environment\tProductName\tUtcDate\tInstance\tRegion\tRequestId\tClientIp\tUserEmail\tApiName\tApiPath\tOperationName\tSubscriptionId\tRequestUrl\tMethod\tStatusCode\tRequestBody\tCorrelationId\tDeviceId\tUserId\tResponseCode\tTotalDuration\tBackendTime";
									var values = string.Empty;
									var clientIP = context.Request.IpAddress;
									var forwarderIP = context.Request.Headers.GetValueOrDefault("X-Forwarded-For", "");
									
									if(!string.IsNullOrEmpty(forwarderIP))
									{
											clientIP = forwarderIP.Split(',').FirstOrDefault().Split(':').FirstOrDefault();
									}
									try
									{
											var requestBody = "NO_BODY";
											if({{IsRequestBodyLogEnabled}} &amp;&amp; context.Request.Body != null)
											{
													requestBody = context.Variables.ContainsKey("tempRequestBody") ? Regex.Replace((string)context.Variables["tempRequestBody"], @"\r\n?|\n|\r|\t", "") :  Regex.Replace(context.Request.Body.As&lt;string&gt;(true), @"\r\n?|\n|\r|\t", "");
											}
											var userId = context.Request.Headers.GetValueOrDefault("X-Customer-Id",   "");
											var totalDurationMS = (System.DateTime.Now.Subtract((DateTime)context.Variables["ReqInTime"])).TotalMilliseconds;
											var backendTimeMS = (System.DateTime.Now.Subtract((DateTime)context.Variables["ReqFwdTime"])).TotalMilliseconds;
											var responseCode = context.Response.Body != null ? (context.Response.Body.As&lt;JObject&gt;(true).SelectToken("responseInfo.responseCode") ?? context.Response.StatusCode).ToString() : context.Response.StatusCode.ToString();
											
											values = string.Join("\t", "{{EnvironmentName}}", context.Product.Name, DateTime.UtcNow.ToString("s") + "Z", context.Deployment.ServiceName,context.Deployment.Region, context.RequestId, clientIP,context.User.Email, context.Api.Name, context.Api.Path, context.Operation.Name,context.Subscription.Id,context.Request.Url.ToUri().ToString(),context.Request.Method, context.Response.StatusCode, requestBody, context.Request.Headers.GetValueOrDefault("X-Global-Context-Id",   ""),context.Request.Headers.GetValueOrDefault("X-Device-Id",   ""),userId,responseCode,totalDurationMS,backendTimeMS);
									}
									catch
									{
											values = string.Join("\t", "{{EnvironmentName}}", context.Product.Name, DateTime.UtcNow.ToString("s") + "Z", context.Deployment.ServiceName,context.Deployment.Region, context.RequestId, clientIP,context.User.Email, context.Api.Name, context.Api.Path, context.Operation.Name,context.Subscription.Id,context.Request.Url.ToUri().ToString(),context.Request.Method, context.Response.StatusCode, "APIMLOGEXCEPTION", context.Request.Headers.GetValueOrDefault("X-Global-Context-Id",   ""),context.Request.Headers.GetValueOrDefault("X-Device-Id",   ""),"APIMLOGEXCEPTION","APIMLOGEXCEPTION","APIMLOGEXCEPTION","APIMLOGEXCEPTION");
									}
									
									return header + "\n" + values;
					}</log-to-eventhub>
</when>
</choose>
    </outbound>
    <on-error />
</policies>

